/**
 * @fileoverview Firestore Security Rules for SecureStock POS and Inventory System.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data, with additional controls for data integrity and auditability.
 * Data relating to Products, Units, and ProductAttributes is globally available for read operations.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles, accessible only to the owning user.
 * - /users/{userId}/saleTransactions/{saleTransactionId}: Stores sale transactions for a specific user, accessible only to that user.
 * - /products/{productId}: Stores product information, publicly readable.
 * - /inventoryBatches/{inventoryBatchId}: Stores inventory batch information, publicly readable.
 * - /saleItems/{saleItemId}: Stores individual sale items, publicly readable.
 * - /auditLogs/{auditLogId}: Stores audit logs, publicly readable.
 * - /units/{unitId}: Stores units of measure, publicly readable.
 * - /productAttributes/{attributeId}: Stores product attributes, publicly readable.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied to prevent unauthorized access to user data.
 * - Public read access is granted to product, inventory, sale items, audit logs, units and product attributes to allow for open access and easy listing. Writes must be secured.
 * - Write access to user documents and sale transactions is restricted to the owning user.
 * - No schema validation is performed during this prototyping phase, except for enforcing ownership on `create` and immutability on `update`.
 *
 * Denormalization for Authorization:
 * - SaleTransactions are stored as subcollections of users to enable owner-based security rules.
 *
 * Structural Segregation:
 * - User-specific data (users and sale transactions) is segregated from public data (products, inventory batches, sale items, audit logs, units and product attributes) to enforce different security postures.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages access to user profiles. Only the authenticated user can read and write their own profile.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile if authenticated as 'user123'.
     * @allow (get, update, delete) User with ID 'user123' can read, update, and delete their profile if authenticated as 'user123'.
     * @deny (create) User with ID 'user123' cannot create a profile with ID 'user456' while authenticated as 'user123'.
     * @deny (get, update, delete) User with ID 'user456' cannot read, update, or delete the profile of 'user123' while authenticated as 'user456'.
     * @principle Enforces document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      // Only signed-in users can attempt to access user documents
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // User listing is not allowed

      // Only the user can create their own document, and the user ID in the document
      // data must match the userId in the path.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;

      // Only the user can update their own document, and the userId cannot be changed.
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;

      // Only the user can delete their own document
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages access to product information. All users can read product information, but only authorized users can create, update, or delete it.
     * @path /products/{productId}
     * @allow (get, list) Any user can read product information.
     * @deny (create, update, delete) No one can modify product information without specific authorization logic.
     * @principle Allows public read access but requires specific authorization for write access.
     */
    match /products/{productId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Product' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages access to inventory batch information. All users can read inventory batch information, but only authorized users can create, update, or delete it.
     * @path /inventoryBatches/{inventoryBatchId}
     * @allow (get, list) Any user can read inventory batch information.
     * @deny (create, update, delete) No one can modify inventory batch information without specific authorization logic.
     * @principle Allows public read access but requires specific authorization for write access.
     */
    match /inventoryBatches/{inventoryBatchId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'InventoryBatch' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages access to sale transactions for a specific user. Only the authenticated user can read and write their own transactions.
     * @path /users/{userId}/saleTransactions/{saleTransactionId}
     * @allow (create) User with ID 'user123' can create a sale transaction under their profile if authenticated as 'user123'.
     * @allow (get, update, delete) User with ID 'user123' can read, update, and delete their sale transactions if authenticated as 'user123'.
     * @deny (create) User with ID 'user123' cannot create a sale transaction under the profile of 'user456' while authenticated as 'user123'.
     * @deny (get, update, delete) User with ID 'user456' cannot read, update, or delete the sale transactions of 'user123' while authenticated as 'user456'.
     * @principle Enforces document ownership for all operations on sale transactions.
     */
    match /users/{userId}/saleTransactions/{saleTransactionId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages access to sale items. All users can read sale item information, but only authorized users can create, update, or delete it.
     * @path /saleItems/{saleItemId}
     * @allow (get, list) Any user can read sale item information.
     * @deny (create, update, delete) No one can modify sale item information without specific authorization logic.
     * @principle Allows public read access but requires specific authorization for write access.
     */
    match /saleItems/{saleItemId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'SaleItem' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages access to audit logs. All users can read audit logs, but only authorized users can create, update, or delete them.
     * @path /auditLogs/{auditLogId}
     * @allow (get, list) Any user can read audit logs.
     * @deny (create, update, delete) No one can modify audit logs without specific authorization logic.
     * @principle Allows public read access but requires specific authorization for write access.
     */
    match /auditLogs/{auditLogId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'AuditLog' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages access to units of measure. All users can read units of measure, but only authorized users can create, update, or delete them.
     * @path /units/{unitId}
     * @allow (get, list) Any user can read units of measure.
     * @deny (create, update, delete) No one can modify units of measure without specific authorization logic.
     * @principle Allows public read access but requires specific authorization for write access.
     */
    match /units/{unitId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Unit' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages access to product attributes. All users can read product attributes, but only authorized users can create, update, or delete them.
     * @path /productAttributes/{attributeId}
     * @allow (get, list) Any user can read product attributes.
     * @deny (create, update, delete) No one can modify product attributes without specific authorization logic.
     * @principle Allows public read access but requires specific authorization for write access.
     */
    match /productAttributes/{attributeId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'ProductAttribute' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the resource.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

    // Helper function to determine if the user is the owner of the resource and it exists.
  function isExistingOwner(userId) {
    return request.auth.uid == userId && resource != null;
  }
}